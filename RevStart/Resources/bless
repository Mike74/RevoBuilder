#!/bin/bash
start ()
{
# 1 volume


bootdev=$( df "${bootvolume}" | sed -n '2p' | awk '{print $1}' )
bootrdev=${bootdev/disk/rdisk}

if [ "${bootdev}" = "${bootdev#*disk*s}" ]
then
	echo
	echo "ERROR Volume does not use slices."
	echo
	exit				
fi

bootdisk=${bootdev%s*}
bootrdisk=${bootdisk/disk/rdisk}
bootslice=${bootdev#*disk*s}
rootdev="`df / | sed -n '2p'`"
rootdev="${rootdev%% *}"
rootdisk="${rootdev%s*}"
echo "Volume is ${bootvolume}"
echo "Volume device is ${bootdev}"
echo "Volume raw device is ${bootrdev}"
echo "Volume slice is ${bootslice}"
echo "Disk device is ${bootdisk}"
echo "Disk raw device is ${bootrdisk}"
echo "Disk loader is ${diskloader}"
echo "Partition loader is ${partitionloader}"
echo "Filesystem loader is ${filesystemloader}"
echo "Root volume device is ${rootdev}"
echo "Root disk device is ${rootdisk}"

}

checkdiskmicrocodetype ()
{
diskmicrocode=$( dd 2>/dev/null if=${bootdisk} count=1 | dd 2>/dev/null count=1 bs=437 | perl -ne '@a=split"";for(@a){printf"%02x",ord}' )

diskmicrocodetypecounter=0
while [ ${diskmicrocodetypecounter} -lt ${#diskmicrocodetype[@]} ]; do
        diskmicrocodetypecounter=$(( ${diskmicrocodetypecounter} + 1 ))
        diskmicrocodetypeid=${diskmicrocodetype[${diskmicrocodetypecounter}]#*,}
        if [ ! "${diskmicrocode}" = "${diskmicrocode/${diskmicrocodetypeid}/}" ]; then
                echo "${diskmicrocodetype[${diskmicrocodetypecounter}]%,*} found."
        fi
done
}

checkdiskmicrocode ()
{
# 1 action ( check or set )

diskmicrocode=$( dd 2>/dev/null if=${bootdisk} count=1 | dd 2>/dev/null count=1 bs=437 | perl -ne '@a=split"";for(@a){printf"%02x",ord}' )
diskmicrocodemd5=$( dd 2>/dev/null if=${bootdisk} count=1 | dd 2>/dev/null count=1 bs=437 | md5 )

if [ $( echo "${diskmicrocode}" | awk -F0 '{print NF-1}' ) = 874 ]
then
	if [ "${1}" = "set" ]
	then
		echo "No disk microcode found. Updating."
		diskupdate=true
	else
		echo "No disk microcode found."
	fi
else
	if [ "${1}" = "set" ]
	then
		echo "Disk microcode found. Preserving."
	else
		echo "Disk microcode found."
	fi
	echo "Disk microcode MD5 is ${diskmicrocodemd5}"
fi
}

checkdisksignature ()
{
disksignature=$( dd 2>/dev/null if=${bootdisk} count=1 | dd 2>/dev/null count=4 bs=1 skip=440 | perl -ne '@a=split"";for(@a){printf"%02x",ord}' )

if [ $( echo "${disksignature}" | awk -F0 '{print NF-1}' ) = 8 ]
then
	echo "No disk signature found."
else
	echo "Disk signature found."
	echo "Disk signature is 0x${disksignature}"
fi
}

checkpartitionbootcode ()
{
# 1 action ( check or set )

partitionbootcode=$( dd if=${bootrdev} count=1 2>/dev/null | perl -ne '@a=split"";for(@a){printf"%02x",ord}' )
partitionbootcodeextended=$( dd if=${bootrdev} count=1 skip=1 2>/dev/null | perl -ne '@a=split"";for(@a){printf"%02x",ord}' )

if [ $( echo "${partitionbootcode}" | awk -F0 '{print NF-1}' ) = 1024 ]
then
	if [ "${1}" = "set" ]
	then
		echo "No partition bootcode found. Updating."
	else
		echo "No partition bootcode found."
	fi
else
	if [ "${1}" = "set" ]
	then
		echo "Partition bootcode found. Overwriting."
	else
		echo "Partition bootcode found."
	fi
	if [ $( echo "${partitionbootcodeextended}" | awk -F0 '{print NF-1}' ) = 1024 ]
	then
		partitionbootcodemd5=$( dd 2>/dev/null if=${bootrdev} count=1 | md5 )
	else
		partitionbootcodemd5=$( dd 2>/dev/null if=${bootrdev} count=2 | md5 )
		echo "Partition bootcode is dual sector."
	fi
	echo "Partition bootcode MD5 is ${partitionbootcodemd5}"
fi
}

checkpartitionactive ()
{
partitionactive=$( fdisk -d ${bootrdisk} | grep -n "*" | awk -F: '{print $1}')

if [ -n "${partitionactive}" ]
then 
	echo "Partition flagged active is ${partitionactive}"
else
	echo "No partition flagged active."
fi

}

DoBless()
{
#bootonly="full"
if [ -d "${1}" ];then
		bootvolume="${1}"
fi
#echo "params are: $bootvolume ${2} ${3}"
if [ -d "${bootvolume}" ]
then
	bootdev=`df "${bootvolume}" | sed -n '2p'`
	bootdev="${bootdev%% *}"
	bootrdev="${bootdev/disk/rdisk}"
	srcBL="${BOOTDIR}"
	loader="Rev"
	diskloader="${srcBL}"/loaders/"${loader}"/boot0
	#diskloader=i386/Loaders/"${loader}"/boot0
	partitionloader="boot1"
	filesystemloader="${srcBL}"/loaders/"${loader}"/boot
else
	echo "Cannot Find The Target Volume. Exiting."
	exit
fi

if [ ! "${bootdev}" ]
then
        {
        echo "Cannot Find The ${bootvolume}. Exiting."
        exit
        }
fi


#exit
if [ "${bootdev}" = "${bootdev#*disk*s}" ]
then
        {
        echo "ERROR Volume does not use slices."
        echo "Volume may be stored on a RAID array."
        echo
        exit
        }
fi
diskmicrocodetype[1]="GRUB,47525542"
diskmicrocodetype[2]="LILO,4c494c4f"
start ${1}


partitiontable=$( dd 2>/dev/null if=${bootdisk} count=1 skip=1 | dd 2>/dev/null count=8 bs=1 | perl -ne '@a=split"";for(@a){printf"%02x",ord}' )
if [ "${partitiontable:0:16}" == "4546492050415254" ]
then	
	partitiontable=$( dd 2>/dev/null if=${bootdisk} count=1 | dd 2>/dev/null count=64 bs=1 skip=446 | perl -ne '@a=split"";for(@a){printf"%02x",ord}' )
	if [ "${partitiontable:8:2}" == "ee" ];then
		if [ "${partitiontable:40:2}" == "00" ] && [ "${partitiontable:72:2}" == "00" ] && [ "${partitiontable:104:2}" == "00" ]
		then
			partitiontable="GPT"
	 	else
			partitiontable="GPT/MBR"
		fi
	fi
else
	partitiontable="MBR"
fi

echo "${partitiontable} found."

#diskupdate=false

checkdiskmicrocodetype
checkdiskmicrocode set
checkdisksignature
checkpartitionbootcode set
checkpartitionactive
if [ "${bootdisk}" = "${rootdisk}" ] 
then
	echo "Boot volume on same disk as root volume. Updating disk microcode not possible."
	diskupdate="false"
elif [ "${backup}" = "no" ]
then
	echo "Boot volume on different disk to root volume."
	diskutil unmountDisk "${bootdisk}"
	sleep 2
	#diskupdate="true"
fi
if [ "${partitiontable}" = "GPT" ] || [ "${partitiontable}" = "GPT/MBR" ]
then
	bootslice="1"
fi	

dd if=${bootdisk} of=${partitiontable}backup bs=512 count=1
	
# copy backup file to work on:
echo "Creating working file....."
cp -p ${partitiontable}backup ${partitiontable}hybrid

# write 440 bytes of boot0 in to working file:
echo "Injecting modified code in to working file....."
dd if="${diskloader}" of=${partitiontable}hybrid bs=440 conv=notrunc count=1

# write MBR back using fdisk:
echo "Write working file back to MBR....."
./fdisk -f ./${partitiontable}hybrid -u -y ${bootdisk}
echo "Done....."
#fi
pushd "${WORKDIR}"/ISO/Extra/i386/loaders/Rev >/dev/null
echo "Executing command: dd if=${partitionloader} of=${bootrdev}"
dd if="${partitionloader}" of="${bootrdev}"
return_val=$?
if [ $return_val = 1 ]
then
	echo "ERROR stage1 bootloader not installed"
	echo "Script aborted"
	echo 	
	exit 1
else
	echo "Stage1 bootloader installed -SUCCESSFULLY-"
fi
popd >/dev/null
# If table is GPT make the first partition active (BadAxe compatibility).
pushd "${WORKDIR}" >/dev/null
./fdisk -f ./${partitiontable}hybrid -e ${bootdisk} <<-MAKEACTIVE
print
flag ${bootslice}
write
y
quit
MAKEACTIVE
popd >/dev/null
echo
sleep 1

}


#bootarguments="${@}"
WORKDIR=$(cd -P -- $(dirname -- "$0") && pwd -P)
cd "${WORKDIR}"
BOOTDIR="${WORKDIR}"/ISO/Extra/i386
EXTRA="${WORKDIR}"/ISO/Extra
KDIR="${WORKDIR}"/Kernels
CommonExtra="${WORKDIR}"/CommonExtra
Themes="${CommonExtra}"/Themes
Motherboard="${WORKDIR}"/Motherboard
boot1File="boot1he"
DoBless "$1"
